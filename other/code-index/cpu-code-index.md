接下来要做：

对新添加的命令，要以后面的 EX 模块的执行来做分类。在 EX 阶段搞定运算。

---

```
cpu-code/
├── cpu-code-index.md
├── defines.v
├── ex.v
├── ex_mem.v
├── id.v
├── id_ex.v
├── if_id.v
├── inst_rom.v
├── mem.v
├── mem_wb.v
├── openmips.v
├── openmips_min_sopc.v
├── openmips_min_sopc_tb.v
├── pc_reg.v
└── regfile.v
```



### 宏定义 [defines.v](./defines.v)

里面是一些整个功能会用到的宏定义，主要是一些 1、0 值的定义，固定的地址、长度。

### 取指阶段的实现

取指阶段取出指令存储器的指令，同时为了取下一条指令 PC 值自增。包括 PC、IF/ID 两个模块。

#### [pc_reg.v](./pc_reg.v)

简单的 PC 指针随时钟自加。

#### [if_id.v](./if_id.v)

简单的寄存器值传递。

### 译码阶段的实现

在此阶段，将对得到的指令进行译码：给出要进行的运算类型，以及操作数。译码阶段包括 Regfile、ID 和 ID\EX 三个模块。

#### [regfile.v](./regfile.v)

32 个 32 位通用整数寄存器，可以同时进行两个寄存器的读操作和一个寄存器的写操作。这个模块中主要就是前面的三部分。

需要注意的是各个使能状态的判断。

- 读取的时候有很多的分支情况判断，需要对应的去处理。
- 里面有组合逻辑和时序逻辑的混合，读操作是组合逻辑会立即发生变化，写操作是时序逻辑只在时钟的上升沿变化。

#### [id.v](./id.v)

对指令进行译码，得到最终运算的类型（逻辑、移位、算数……）、子类型（与、或、异或……）、源操作数 1、源操作数 2、目的寄存器地址。

对于 ori 指令，指令中仅几位就指明了指令类型。指令中包含有立即数，有写入地址。

### 执行阶段的实现

将对译码阶段的结果：源操作数 1、源操作数 2，进行指定的运算。执行阶段包括 EX、EX/MEM 两个模块。

#### [ex.v](./ex.v)

ex 模块中都是组合逻辑电路。

执行阶段分计算和结果的处理。计算会根据具体的操作类型来对操作数进行运算。

结果处理主要考虑寄存器的回写。

#### [ex_mem.v](./ex_mem.v)

### 访存阶段的实现

访存阶段本来是要访问数据存储器的，但是由于 ori 命令并不需要，所以只需要简单的将值传递到 mem_wb 模块，再完成数据的回写就好。

mem_wb 模块其实是把数据传递到了 regfile 模块，实际的写入是在 regfile 中实现的。

#### [mem.v](./mem.v)


#### [mem_wb.v](./mem_wb.v)

### 顶层模块 OpenMIPS 的实现

顶层模块其实只是简单的把其他模块实例化和连接。

### 指令存储器 ROM 的实现

#### [inst_rom.v](./inst_rom.v)

从预配置的文件 `inst_rom.data` 中读取数据初始化，然后简单的做一个地址映射，从而实现 ROM。

每行存储 32 位宽度用十六进制表示的指令。类似下面这样：

```
34011100
34020020
3403ff00
3404ffff
```

指令地址要除以 4 来和这里的对应。

ROM 里面实际有 10 位宽的数据。

### 最小 SOPC 的实现

做一个 SOPC，仅含有 OpenMIPS、指令存储器 ROM，所以是最小的 SOPC。从指令寄存器读取指令，指令进入 OpenMIPS 执行。

#### [openmips_min_sopc.v](./openmips_min_sopc.v)

#### [openmips_min_sopc_tb.v](./openmips_min_sopc_tb.v)

测试用

## Todo

- [X] 顶层模块
- [X] 使用查找替换命令修复一点错误
- [X] inst rom 模块
- [X] 最小 sopc
- [X] 必须的测试文件
- [ ] 调试

## 小知识点

### 赋值

`pc <= 32'h00000000;` 为非阻塞赋值。

而使用 `==` 的时候为阻塞赋值。前面还可以加延时的时间。

```
#5 rst = 1'b0;
```

### 赋值拼接

```
imm <= {`ZeroWord[`RegWidth - 1 : 5], op_sa};
```

### 从文本文件中读取数据

使用 `$readmemh` 函数，读取文件内容。

### Testbench 的 timescale

```
`timescale 仿真时间单位/时间精度
`timescale 1ns/1ps
```

### 汇编指令的格式

```
add a,b,c 		# a <= b + c
```

- `rs rt rd` -> `rd <= rs x rt`
- `rs rt immediate` -> `rt <= rs x immediate`

## 疑问

在流水线中，直到最后一级才会把数据写入到寄存器中。那么下一条指令不是已经在第四级了，那么结果数据还能让下一条命令使用吗？如果出现这样的情况要怎么办？

ROM 和 RAM 是怎样使用的。

写给单片机的 C 语言编译完成后会什么会知道 RAM 占用多少？又没有实际去跑，怎么会知道的？如果使用递归会怎样呢？函数调用的堆栈是由谁来实现的，编译器还是说不用的？

马上到了编译哪里就知道了，加油啊！
