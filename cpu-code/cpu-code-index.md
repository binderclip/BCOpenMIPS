
```
cpu-code/
├── cpu-code-index.md
├── defines.v
├── ex.v
├── ex_mem.v
├── id.v
├── id_ex.v
├── if_id.v
├── pc_reg.v
└── regfile.v
```



### 宏定义 [defines.v](./defines.v)

里面是一些整个功能会用到的宏定义，主要是一些 1、0 值的定义，固定的地址、长度。

### 取指阶段的实现

取指阶段取出指令存储器的指令，同时为了取下一条指令 PC 值自增。包括 PC、IF/ID 两个模块。

#### [pc_reg.v](./pc_reg.v)

简单的 PC 指针随时钟自加。

#### [if_id.v](./if_id.v)

简单的寄存器值传递。

### 译码阶段的实现

在此阶段，将对得到的指令进行译码：给出要进行的运算类型，以及操作数。译码阶段包括 Regfile、ID 和 ID\EX 三个模块。

#### [regfile.v](./regfile.v)

32 个 32 位通用整数寄存器，可以同时进行两个寄存器的读操作和一个寄存器的写操作。这个模块中主要就是前面的三部分。

需要注意的是各个使能状态的判断。

- 读取的时候有很多的分支情况判断，需要对应的去处理。
- 里面有组合逻辑和时序逻辑的混合，读操作是组合逻辑会立即发生变化，写操作是时序逻辑只在时钟的上升沿变化。

#### [id.v](./id.v)

对指令进行译码，得到最终运算的类型（逻辑、移位、算数……）、子类型（与、或、异或……）、源操作数 1、源操作数 2、目的寄存器地址。

对于 ori 指令，指令中仅几位就指明了指令类型。指令中包含有立即数，有写入地址。

### 执行阶段的实现

将对译码阶段的结果：源操作数 1、源操作数 2，进行指定的运算。执行阶段包括 EX、EX/MEM 两个模块。

#### [ex.v](./ex.v)

ex 模块中都是组合逻辑电路。

执行阶段分计算和结果的处理。计算会根据具体的操作类型来对操作数进行运算。

结果处理主要考虑寄存器的回写。

#### [ex_mem.v](./ex_mem.v)

## 小知识点

### 赋值

`pc <= 32'h00000000;` 为非阻塞赋值。

而使用 `==` 的时候为阻塞赋值。前面还可以加延时的时间。

```
#5 rst = 1'b0;
```