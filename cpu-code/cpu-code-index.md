
```
cpu-code/
├── cpu-code-index.md
├── defines.v
├── ex.v
├── ex_mem.v
├── id.v
├── id_ex.v
├── if_id.v
├── mem.v
├── mem_wb.v
├── openmips.v
├── pc_reg.v
└── regfile.v
```



### 宏定义 [defines.v](./defines.v)

里面是一些整个功能会用到的宏定义，主要是一些 1、0 值的定义，固定的地址、长度。

### 取指阶段的实现

取指阶段取出指令存储器的指令，同时为了取下一条指令 PC 值自增。包括 PC、IF/ID 两个模块。

#### [pc_reg.v](./pc_reg.v)

简单的 PC 指针随时钟自加。

#### [if_id.v](./if_id.v)

简单的寄存器值传递。

### 译码阶段的实现

在此阶段，将对得到的指令进行译码：给出要进行的运算类型，以及操作数。译码阶段包括 Regfile、ID 和 ID\EX 三个模块。

#### [regfile.v](./regfile.v)

32 个 32 位通用整数寄存器，可以同时进行两个寄存器的读操作和一个寄存器的写操作。这个模块中主要就是前面的三部分。

需要注意的是各个使能状态的判断。

- 读取的时候有很多的分支情况判断，需要对应的去处理。
- 里面有组合逻辑和时序逻辑的混合，读操作是组合逻辑会立即发生变化，写操作是时序逻辑只在时钟的上升沿变化。

#### [id.v](./id.v)

对指令进行译码，得到最终运算的类型（逻辑、移位、算数……）、子类型（与、或、异或……）、源操作数 1、源操作数 2、目的寄存器地址。

对于 ori 指令，指令中仅几位就指明了指令类型。指令中包含有立即数，有写入地址。

### 执行阶段的实现

将对译码阶段的结果：源操作数 1、源操作数 2，进行指定的运算。执行阶段包括 EX、EX/MEM 两个模块。

#### [ex.v](./ex.v)

ex 模块中都是组合逻辑电路。

执行阶段分计算和结果的处理。计算会根据具体的操作类型来对操作数进行运算。

结果处理主要考虑寄存器的回写。

#### [ex_mem.v](./ex_mem.v)

### 访存阶段的实现

访存阶段本来是要访问数据存储器的，但是由于 ori 命令并不需要，所以只需要简单的将值传递到 mem_wb 模块，再完成数据的回写就好。

mem_wb 模块其实是把数据传递到了 regfile 模块，实际的写入是在 regfile 中实现的。

#### [mem.v](./mem.v)


#### [mem_wb.v](./mem_wb.v)

### 顶层模块 OpenMIPS 的实现

顶层模块其实只是简单的把其他模块实例化和连接。

## Todo

- [X]顶层模块
- []使用查找替换命令修复一点错误
- []最小 sopc
- []必须的测试文件

## 小知识点

### 赋值

`pc <= 32'h00000000;` 为非阻塞赋值。

而使用 `==` 的时候为阻塞赋值。前面还可以加延时的时间。

```
#5 rst = 1'b0;
```

## 疑问

在流水线中，直到最后一级才会把数据写入到寄存器中。那么下一条指令不是已经在第四级了，那么结果数据还能让下一条命令使用吗？如果出现这样的情况要怎么办？

ROM 和 RAM 是怎样使用的。

写给单片机的 C 语言编译完成后会什么会知道 RAM 占用多少？又没有实际去跑，怎么会知道的？如果使用递归会怎样呢？函数调用的堆栈是由谁来实现的，编译器还是说不用的？

